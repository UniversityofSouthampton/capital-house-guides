{"Unity/Coding/Advanced-CSharp/index":{"slug":"Unity/Coding/Advanced-CSharp/index","filePath":"Unity/Coding/Advanced CSharp/index.md","title":"Unity - C# Advanced Practices + Tips and Tricks","links":[],"tags":[],"content":"This guide is ever-growing!\nThere are hundreds of practices, cheats, tips and tricks within Unity - way too many to document in one go! This guide will updated over time, and students are welcome to contribute to it!\nLast updated: 13.02.25\nFeel like you are familiar with C# scripting and want to take your coding to the next level? This guide is for you! In no particular order, here are some more advanced C# (and general programming) practices you may not have known about!\nDid you know: C#\nDid you know: you can embed any variable directly into a string, without having to append it?\nAppend $ to the start of the string, and surround any variables with curly brackets:\nC#\nstring name;\nint age;\n\n//Instead of\nDebug.Log(&quot;Hi &quot; + name + &quot;, you are &quot; + age + &quot; years old!&quot;);\n\n//Yuck!\n\n//We can write\nDebug.Log($&quot;Hi {name}, you are {age} years old!&quot;);\n//Wow!\n\nDid you know: you can simplify simply if-else statements?\nThe Ternary Operator (?) can use a boolean expression to select one of two options:\nC#\nstring rossIsLate;\n\n//Instead of\nif(time &gt; 10)\n{\n\trossIsLate = &quot;yes&quot;;\n}\nelse\n{\n\trossIsLate = &quot;no&quot;;\n}\n\n//Yuck!\n\n//We can write\nrossIsLate = (time &gt; 10) ? &quot;yes&quot; : &quot;no&quot;;\n\n//result = (condition) ? &lt;option if true&gt; : &lt;option if false&gt;;\n//Wow!\n\nDid you know: you can simplify null checks with the null-conditional operator (?.)\nC#\nGameObject enemy;\n\n//Instead of \nif(enemy != null)\n{\n\tenemy.SpontaneouslyCombust();\n}\n\n//Yuck!\n\n//We can write\nenemy?.SpontaneouslyCombust();\n\n//Wow!\n\nDid you know: you can set any variable type as nullable with T?\nC#\n// num can be ...,-2,-1,0,1,2,...\n// it can not be null, it is 0 by default.\nint num;\n\n//Yuck!\n\n// coolerNum can be ...,-2,-1,0,1,2,...\n// but it can also be null (and is null by default)\nint? coolerNum;\n\n//Wow!\n\nProgramming Design Patterns\nDesign patterns are common solutions to issues one can face while programming. Like a blueprint, you can think of them as general concepts for solving common challenges. Design patterns are not anything specific in any language, but are more general concepts that are universally understood by programmers. The actual implementation may differ depending on who is programming.\nYou can learn more about design patterns here: refactoring.guru/design-patterns/what-is-pattern\nThe “Singleton” pattern is one of the most used design patterns out there, and for a good reason! If you have only one instance of a script, it allows you to reference that script from anywhere in the code in just one simple line.\nThis is particularly useful for game development: think of any time that you had a script such as CharacterMovement.cs, or GameManager.cs, something that you want to reference a lot in other scripts.\nOrdinarily, you would need to create a variable to hold a reference to that script, and then either use GetComponent&lt;&gt; or drag the script in manually through the editor. This can get messy really quick.\n\n\n\nEvery time you want to reference CharacterController (a script on the Player), you have to first get a reference to the Player (expensive) then use GetComponent (expensive). A lot of repeated code, a lot of expensive calls. Good for quick prototypes, not the best idea for full games.\n\n\nNow imagine if, at any point throughout any script, you could simply write CharacterMovement.instance and have an instance of that script. This is made easy with singletons:\n\n\n\nAssuming there is only one instance of CharacterController in any given scene, the singleton pattern exposes a very handy CharacterController.instance variable, allowing you to reference that script in one line, anywhere in your project, without having to create unnecessary variables or run expensive calls.\n\n\nLearn more about singletons: refactoring.guru/design-patterns/singleton\nSingletons in Unity\nImplementing singletons in Unity is super easy. Create a new script in your project: Singleton.cs\nPaste this code:\nC#\nusing UnityEngine;\n\n//Singleton Pattern\npublic abstract class Singleton&lt;T&gt; : MonoBehaviour where T : MonoBehaviour\n//When defining a new singleton, T (or type) can be any other monobehavior\n//This helps us seperate one type of singleton from any other\n{\n    \n    //static = the value of the variable is synced between all instances of this script\n    private static T instance;\n    //A private variable to hold the instance of the singleton\n    \n    public static T Instance =&gt; instance;\n    //A public variable which returns the instance\n    \n    protected void Awake()\n    //Before OnEnable() and Start() - this will likely be the first code run for any script\n    {\n        if (instance == null)\n        {\n            instance = this as T;\n        }\n        //if no instance has been set yet, set the current instance as &quot;The Instance&quot;\n        else if (instance != this)\n        {\n            Debug.LogWarning(&quot;Multiple instances of the singleton type &#039;&quot; + instance.GetType() + &quot;&#039; were found. Deleting this instance&quot;);\n            Destroy(gameObject);\n        }\n        //If multiples are detected, delete multiple\n    }\n}\n\nAs mentioned, this is only one possible implementation and you may find ones that differ online.\nNow head to the script that you want to make a singleton. Remember: You should only have one instance of the script in the scene, otherwise this pattern will delete any duplicates!\nWith ScriptName being the name of your script, change the top of your script from\npublic class ScriptName : MonoBehaviour\n\nto\npublic class ScriptName : Singleton&lt;ScriptName&gt;\n\nand you’re good to go! You should now be able to reference the script by typing ScriptName.Instance anywhere in your project!\nAt runtime, any number of things can occur in your game. What happens when you kill an enemy? How about when you collect a power-up or complete an objective? You may often need a mechanism that allows objects to notify others without directly referencing them.\nThe observer pattern is a common solution to this problem. It allows your objects to communicate using a “one-to-many” dependency. When one object changes state, all dependent objects get notified automatically:\n\nThe observer pattern is made possible in Unity using Events and Delegates.\nIn Unity\nSo far, you have probably been using Update() to trigger changes in an object. And this works for checks that need to happen on a frame-by-frame basis, such as checking for keypresses and moving a character accordingly. But many states in your game don’t need to update every frame, such as the UI that shows the amount of currency that your player has, or whether or not to show the “Game Over” screen. Using event-based logic, we can make it so code on certain objects (observers) is only triggered when one specific object (the subject) says so.\nDelegates\nDelegates are “function containers”. They hold a list of functions to be called at a certain point.\nC#\nusing UnityEngine;\n\npublic abstract class Currency : MonoBehaviour\n{\n\n    public static int amount = 1000;\n    \n    //Define a new delegate template\n    //For example, all functions inside this delagate:\n    //- Return &#039;void&#039; (aka nothing)\n    //- Have no parameters\n    delegate void OnCurrencyChanged();\n    \n    //Create an instance of this delagate\n    //This delegate can now store functions and invoke them\n    OnCurrencyChanged onCurrencyChanged;\n    \n    private void Start()\n    {\n    \t//Subscribe the &quot;UpdateCurrencyUI&quot; function to our delegate\n    \tonCurrencyChanged += UpdateCurrencyUI;\n    \t\n    \t//At any point, we can subscribe more functions: \n    \t\t//[delegate] += [function];\n    \t\t\n    \t//unsubscribe those functions:\n    \t\t//[delegate] -= [function];\n    \t\t\n    \t//overwrite all functions with just one function:\n    \t\t//[delegate] = [function];\n    \t\t\n    \t//or clear the delegate entirely\n    \t\t//[delegate] = null;\n    }\n    \n    public void UpdateCurrencyUI()\n    {\n    //Code to update UI text for currency\n    }\n    \n    \n}\n\nCurrently we have a delegate onCurrencyChanged with one function, UpdateCurrencyUI\nMeaning that when we invoke this delegate, it will run that function, and any other function we add to it. But how do we actually invoke this delegate?\nC#\n...\npublic void AddCurrency(int addAmount)\n{\n\tamount += addAmount;\n\t\n\t//At this point, we know that the state of &#039;currency&#039; changes,\n\t//so we should invoke our delegate now\n\t\n\tonCurrencyChanged?.Invoke();\n\t\n\t//[delegate].Invoke() calls all subscribed functions\n\t//If the delegate is null (has no subscribers), this\n\t//will throw an error.\n\t//By appending ?, the delegate is only invoked if it is not null\n}\n...\n\nThis is great if all of the subscribed functions are on the same script as the delegate, but what if we want to subscribe functions from a different script or object?\nPublic Static Delegates\npublic static OnCurrencyChanged onCurrencyChanged;\nThis means two things:\nThe delegate will be the same across all instances of Currency.cs;\nand we can access this delegate anywhere from within our codebase.\nLet’s separate our logic into two scripts:\nCurrency.cs - Responsible for managing the state of our currency\nC#\nusing UnityEngine;\n\npublic abstract class Currency : MonoBehaviour\n{\n\t\t\n    public static int amount = 1000;\n    \n    delegate void OnCurrencyChanged();\n    OnCurrencyChanged onCurrencyChanged;\n    \n    public void AddCurrency(int amount)\n\t\t{\n\t\t\tcurrency += amount;\n\t\t\t\n\t\t\tonCurrencyChanged?.Invoke();\n\t\t}\n    \n}\n\nPlayerStatsUI.cs - Solely responsible for updating UI\nC#\nusing UnityEngine;\n\npublic abstract class PlayerStatsUI: MonoBehaviour\n{\n\n    [SerializeField] TMP_Text currencyLabel;\n    \n    //It is good practise to unsubscribe any functions\n    //from this script when it is disabled, as attempting to\n    //call a function on a disabled object will cause errors.\n    \n    private void OnEnable()\n    {\n    \t//subscribe UpdateCurrencyUI to the delegate\n    \tCurrency.onCurrencyChanged += UpdateCurrencyUI;\n    }\n    \n    private void OnDisable()\n    {\n    \t//unsubscribe UpdateCurrencyUI from delegate\n    \tCurrency.onCurrencyChanged -= UpdateCurrencyUI;\n    }\n    \n    //Only runs when invoked by delegate\n    public void UpdateCurrencyUI()\n    {\n    \tcurrencyLabel.text = Currency.amount;\n    }\n    \n}\n\nEvent Delegates\npublic static event OnCurrencyChanged onCurrencyChanged;\nBy adding an ‘event’ modifier to our delegate, only the script which defines the delegate can invoke it. Subscriber classes can not invoke the delegate, nor can they overwrite or clear it.\nWhile the functionality is the same, this reduces our chance of errors.\nSee also: Actions in Unity, Unity Events, and Scriptable Object Events."},"Unity/Coding/CSharp-Resources/index":{"slug":"Unity/Coding/CSharp-Resources/index","filePath":"Unity/Coding/CSharp Resources/index.md","title":"Unity - C# and Scripting Resources","links":[],"tags":[],"content":"Learning to code can seem daunting, but the only way to get better is through exposure! There are thousands of tutorials online all with unique learning styles. The best way to learn coding is by doing it, and in this post, I will recommend some resources to get you started!\nOfficial Series by Unity: Beginner Scripting\nThis series assumes basic knowledge of Unity so it is recommended that you first complete the “Unity - Introduction” guide. The guide includes pre-written code but does not expect you to write your own. Once you have completed it, you may want to learn more about the individual elements and structures which make up a script, in which case this series is perfect for you.\nlearn.unity.com/project/beginner-gameplay-scripting\nScript Editor\nThe guide uses an older version of Visual Studio as the script editor. You should use Rider as your editor (see Unity - Introduction guide for steps on how to set your default script editor.)\nI strongly recommend watching these videos:\n\n\nScripts as Behaviour Components\n\n\nVariables and Functions\n\n\nConventions and Syntax\n\n\nIF Statements\n\n\nLoops\n\n\nScope and Access Modifiers\n\n\nAwake and Start\n\n\nUpdate and FixedUpdate\n\n\nVector Maths\n\n\nFeel free to watch more of the series if you wish!\nCodeCademy\nCodeCademy is a website which provides interactable coding courses, meaning you will learn by practice!\nTheir C# course is free and will give you a good foundation of the features and syntax of C#\nIf you prefer to learn at your own pace by following a written guide, you will enjoy this course.\nI recommend completing all of the tutorials up until (and including) Methods.\nwww.codecademy.com/learn/learn-c-sharp\nNotice\nCodeCademy will teach you the general basics of C#. While all of the knowledge covered by the course is transferrable to Unity, keep in mind that there are certain Unity-specific features that this course won’t cover."},"Unity/Coding/index":{"slug":"Unity/Coding/index","filePath":"Unity/Coding/index.md","title":"Unity - Coding","links":[],"tags":[],"content":""},"Unity/Introduction/2D/Simple-2D-Player-Controller/index":{"slug":"Unity/Introduction/2D/Simple-2D-Player-Controller/index","filePath":"Unity/Introduction/2D/Simple 2D Player Controller/index.md","title":"Unity - Simple 2D Player Controller (Top-Down &amp; Platformer)","links":[],"tags":["2d","introduction","scripting","unity"],"content":"Note: This is a student-submitted guide. Please comment or get in touch with me (Parker) for suggestions or clarification!\nIntro\nIn the Introduction tutorial you will have been introduced to Unity by making a simple player controller. This one will also be a very simple controller with minimal code, but will be a lot more customizable for any kind of 2D game you need. The code for movement, jumping etc. will all be seperate, so you can make a top-down game without jumping (Stardew Valley, Cult of the Lamb) or a side-scrolling platformer (Super Mario Bros, Hollow Knight, Celeste).\nYou will be able to tweak any value you want for your movement to make it as satifsying as possible, including:\n\n\nTop Speed\n\n\nAcceleration\n\n\nJump Height\n\n\nJump/Fall Curves\n\n\nMid-Air Jumps\n\n\nThis tutorial will be heavily adapted from this video by Shinjingi on Youtube, which I highly recommend watching.\nPart One: Setting the Scene\nFirstly, create your Unity project and ensure it is using the Universal 2D template.\nBefore we make our character, we need a space for them to move on. Right click on the blank space in the Hierarchy window on the left and create a new 2D Sprite &gt; Square. Set its Position in the Inspector panel on the right to X: 0, Y: -4.5, Z: 0. Then set its Scale to X: 20, Y: 1, Z: 1. This creates a floor.\n\n\n\nQuick tip: You can right-click the top bar on the Transform component &amp; click Reset to reset all the values to default before this.\n\n\nThe floor is still just a sprite with no functionality, so we will need to add a Component to let it interact with the player using physics. Click the Add Component button at the bottom of the list of components in the Inspector, and search for the Rigidbody 2D component. Now that it’s been added, click the Body Type dropdown and select Static. Now the floor can interact with the player, but won’t move by itself.\nAlthough we’ve given the floor a Rigidbody component, we still need it to be able to collide with the player, so they can stand on it. Add another new component and search for the Box Collider 2D component.\nNow, select the Camera object in the Hierarchy panel, and set its Size in the Inspector panel to 10 so everything is in frame.\n\nPart Two: Creating the Player\nTo create the player, right click the Hierarchy window again and add a new 2D Sprite &gt; Square. Ensure their Position is at X: 0, Y: 0, Z: 0 so they are directly above the floor we made.\n\nNow add a Rigidbody 2D component the same way as before. Set the Body Type to Dynamic, as our player will be moving. Set the Collision Detection to Continuous, and set Interpolate to Interpolate. This should give our player some accurate and smooth collisions for hitting the floor no matter how fast they’re going. Then under the Constraints dropdown, check Freeze Rotation on the Z axis. This stops your character from spinning around.\n\nNow that’s done it’s finally time to start coding!\nPart Three: Side-to-Side Movement\nThe different parts of the controller like moving, jumping etc. will be made in different script components, so you can pick and choose what you want to include in your game. For this first one we will be handling input and letting the player move side to side.\nHandling Player Input\nFor player input we will be using Unity’s new Input System, as it allows for managing several input methods (Keyboard, Controller, etc.) much more smoothly than the old Input Manager. Information on installing it and an explanation of creating Input Actions using it can be found on the Input System Quick Start Guide.\nUsing the Input System\nAfter creating an Input Actions Asset, open it and create a new Action Map called Gameplay. Rename the existing Action created in the Map to “Move”.\n\n\n\nRemember to click the “Save Asset” button!\n\n\nIn the action properties panel on the right, set the Action Type to Value and the Control Type to Vector 2. This means our input (from a joystick or keyboard) is going to be read as a two-dimensional vector.\nNow the action has been created, we need to add some bindings to it. Click the plus (+) icon next to the Move binding and select Add Up\\Down\\Left\\Right Composite. Optionally, you can right click and delete the Up and Down bindings if you don’t need them (i.e if you’re making a platformer character). Now we have bindings for going up, down, left and right.\n\nSelect the Left binding &amp; click on the dropdown next to Path in the properties panel. Then just hit the key you want to correspond to Left and select it with the mouse. I chose the “A” key in this case, and selected “A [Keyboard]” in the list. Then do the same with your Right binding. I chose the “D” key.\n\nIf you want to add gamepad support, click the plus icon and click Add Binding. Then under the Path search for and select “Left Stick [Gamepad]”.\nFinally, click the Save Asset button at the top(!!!). In the Inspector Panel, select “Generate C# Class”, and hit apply. You’re done!\nCreating the Input Script\nBefore implementing any movement code, we will first create a script component that handles the player’s input. Keeping it seperate to our Move script keeps our code clean and also gives us the possibility of having AI-controlled NPCs move using the same way as our character, which will be covered in a future tutorial. (Also, you’ll be able to use this controller in 3D games too!)\nIn the Scripts folder, create a new folder called Controllers. Then Create &gt; C# Script. Name this script PlayerController. Open it in Rider (please refer to the “Your First Script” section in the Introduction tutorial if you do not know how to enable Rider in your editor!). You should be met with the default empty script code as shown below.\n\nYou can safely delete the two Start and Update functions here, as we won’t be needing them.\nWe will first create a variable for the InputActions asset we made earlier. Create a private variable with type InputActions and name “inputActions”.\nPro Tip: If you didn’t know already, press Tab to auto-complete the suggested value that pops up when coding. You can use the up/down keys to switch between selections.\n\n\n\nThe scope of the variable is private as it’s only ever used within this script.\n\n\nNow we need to enable the InputActions asset &amp; the Gameplay action map by using an OnEnable() function under this.\n\n\n\nThe OnEnable() function runs whenever this script is enabled (in this case immediately).\n\n\nNow we need to make a function for getting the direction &amp; magnitude of our input aka a vector. After declaring the variable, Create a public function called “RetrieveMoveInput” that takes a GameObject as an input.\nThen, get it to return the value of the Move binding as a vector using the following code.\n\n\n\nThe function is public as we will be calling it inside our Movement script.\n\n\nNow we can move onto the fun part: creating the movement code!\nCreating the Movement Script\nIn the Scripts folder create a new folder called Capabilities. Then in the Capabilities folder create a new C# Script called Move.\nNow it’s time to create our variables. Firstly we need one for the input script we just made. Declare a private PlayerController variable called “input”.\n\nNow create some private float variables for the max speed and acceleration. We add [SerializeField] before the variables here with a limited Range so that they can show up as sliders to adjust in the Inspector panel.\n\nAfter that we need to declare variables for values that will be used in our movement calculations.\n\nDelete the Start function and create an Awake function, and inside it set the “body” variable to be the Rigidbody 2D component we added earlier. We can do this by using the built-in GetComponent function.\n\n\n\nThe Awake function is always run first in the script, no matter what.\n\n\nIn the Update function, set our direction to be the RetrieveMoveInput we created earlier. Then, we create a new vector consisting of just the X axis, or horizontal part, of our input direction. After that we set the desired velocity to be the horizontal vector with its magnitude multiplied by our Max Speed variable.\n\nNow create a new FixedUpdate function. FixedUpdate repeats constantly like the Update method but doesn’t depend on framerate, but rather fixed intervals of time. If you’ve ever played an old game that runs way too slow or too fast depending on how fast your PC is, it’s because they didn’t do this.\nIn the function, firstly get our rigidbody’s current velocity to start with.\n\nNow we calculate the maximum speed change value, by multiplying acceleration by the change in time. After that, we move our current velocity towards the max speed using that value.\n\n\n\nYou don’t need to 100% understand all the maths for this. All you have to know is that the MoveTowards function will let us set how fast we get up to the max speed by changing Max Acceleration in the editor later.\n\n\nFinally, set the rigidbody velocity to our newly calculated velocity value.\n\nNow, back in the editor, select the player and add the PlayerController and Move script components.\nHit the Play button above the viewport and you should be able to move your character! Adjust the max speed and acceleration values to your taste. I suggest turning up Max Acceleration to make the movement feel less floaty.\n\nOPTIONAL: Up and Down Movement\nThis side to side movement would work great for something like a platformer. However, there are also games with top-down 2D movement like Don’t Starve, Cult of the Lamb and Vampire Survivors which you might want to make. Let’s modify our code to allow for that now.\nUp and Down Input Actions\nFirstly we need to re-implement the actions for “up” and “down” in our Input Actions asset. Go back to our 2D vector binding and bind new buttons for the Up and Down parts like we did earlier. In this example I used the W and S keys respectively.\n\nNow all we need to do is update our movement script to let us move up and down.\nModifying the Movement Script\nOpen the Move.cs file back up. You’ll see that there’s already an error when we set the direction variable, as we were only setting the X axis part of it.\n\nDelete the “.x” part at the end here too.\n\nIn the line under where we calculate our desired velocity, remove the vector we created with the Y part set to zero, and just replace it with our input direction variable.\n\nNow, in our FixedUpdate function, remove all the “.x” parts we added to the velocity and desired velocity variables, and change the Mathf.MoveTowards function to a Vector2.MoveTowards function, as we’re dealing with 2D vectors instead of numbers now.\n\nNow that all the coding’s done, go back to the editor and set the gravity scale of your Player object’s rigidbody to 0 in the inspector. You don’t want your player constantly going downwards in a top-down game.\n\nNow you should be able to move the character perfectly! Again, adjust the top speed and acceleration values to taste.\n\nPart Four: Implementing Jumps\nOnce you have side-to-side movement working, you will probably want to implement a Jump capability. To do that we first need to add a new input binding for it.\nAdding the Jump Input\nThis is the same as creating your movement bindings, just open up your InputActions asset, and add a new Action using the plus at the top of the Actions bar. Name this action “Jump”.\n\nIt should already come with a binding, so just set the path to whatever key or button you want. I chose Space on the keyboard, but you can also add a new binding for a button on the controller. I chose the South button, which is A on an Xbox controller, B on a Nintendo controller, and X on a Playstation controller. And O on an Ouya controller (okay I’ll shut up now).\nNow we have to add the bindings to our Player Controller script. We may want the player to be able to influence the height of their jump depending on how long the button is pressed like in many other popular platformer games, so we will have seperate states for the jump starting and ending depending on the button input.\nFirstly, open the PlayerController.cs script and create a new private bool variable called isJumping so we can keep track of whether the input is pressed.\n\nNow, we will need to add functions to set isJumping to true or false based on the input starting and stopping. Create two private void functions called JumpStarted and JumpCanceled. These take weird CallbackContext variables as input, they’re unfortunately necessary to include.\n\nNow in the OnEnable function we make sure these functions are listening for the input action.\n\nFinally, we need to create a new public function to return the value of our isJumping variable so we can use it in our movement script.\n\nNow our inputs are ready for jumping. However, before we implement the jump code we need to add a check if the player is on the ground before allowing them to jump in the first place.\nCreating a Ground Check\nIn your Scripts folder, create a new folder called Checks. Within that folder create a script called Ground. In this we are going to check all the things the player is colliding with (aka what they’re touching) and check whether one of them is the ground or not. We will first need to create a private void function called EvaluateCollision, that takes a variable of type Collision2D as input.\n\nTo check the collision we are going to use what is known as a for loop, basically meaning we go through a list of data (in this case contact points of the collision) and refer to the current one we’re on (the 1st, 2nd, 3rd etc…) using the variable “i”. Then we can run tests on this “i” point to see if it is flat enough to be considered ground. I have made a fantastically detailed diagram showing how a for loop iterates through a list:\n\n\n\nAlso, computers start counting a list at 0. Dont ask me, that’s just how it works.\n\n\nTo do this we check the “normal” (basically the angle between us and the point we contact the floor). If the normal is 1 it is completely flat under us, but we will consider anything over 0.9 as ground just in case. If that is true, onGround is set to true, but otherwise it stays false.\n\n\n\n“i++” means we add 1 to i after we check the collision, so we can move onto the next one in the list.\n\n\nNow we just have to run this code whenever we make contact, or a collision, with another object. Unity has some built-in functions for this, so we’ll use them now.\n\nFinally, we’ll create a function to return our onGround value so we can use it in our jump script.\n\nCreating the Jump Script\nWe’re going to create a whole new script for jumping, again for the sake of modularity. Go to the Capabilties folder and create a C# Script called Jump.\nThis jump method will have different amounts of gravity applied on the player for both their upwards and downwards arc of their jump independently. This results in a satisfying stronger plummet to the ground as the player falls, which has been used in 2D platformer games from the original Super Mario Bros all the way up to modern titles like Celeste. The amount we hold the jump button for will also be accounted for in this, allowing for shorter hops by simply tapping the jump button. This is obviously unrealistic so I would only recommend this method for 2D platformer type games.\nTo start we need to declare some variables again. We’ll start with the ones we can change in the Inspector panel. This will be our jump height, the maximum amount of mid-air jumps we can do, and the amount of gravity that gets applied upwards and downwards.\n\nThen we declare the rest of the variables we’ll be using in our code.\n\n\n\nThis is a lot to add, but trust me, we’ll be needing all of them.\n\n\nNow, change the provided Start function to an Awake function, and within it get the Ground, PlayerController and Rigidbody components we need. We will also set the default gravity scale to 1 and make sure our JumpReset variable is set (this is to stop the player from constantly jumping when holding the button down).\n\nNow, in the Update function we check for our Jump input, and set the value of that to the desiredJump variable.\n\nNow for the jump logic. We will start with the FixedUpdate function. Set the onGround variable using the GetOnGround function we wrote earlier and set our velocity variable using the current velocity of our rigidbody.\n\nNow we set our jumpPhase variable, with an if statement checking if we are on the ground and not moving up or down.\n\nAfter that, we make another if statement, seeing if our Jump Reset variable is true, and that the player has pressed the jump input. If both are true (signified by the &amp;&amp; or “and” operator there), we set both to false and then execute a JumpAction function that contains our code for actually doing the jump. We’ll make that later.\n\nUnder that, we make another if statement that applies our different gravity scales based on if we’re going up or down.\n\nFinally, we set our rigidbody’s velocity to our own velocity variable.\n\nNow it’s time to make our JumpAction function. Start with an if statement with the following condition. This uses the || or “or” operator, to check if we are either:\n\n\nOn the ground;\n\n\nOur maxAirJumps variable is greater than or equal to our jumpPhase. The jumpPhase is set to 0 when the player hits the ground and 1 when a jump is executed. Therefore, if maxAirJumps is set to 1, we get one mid-air jump and so on.\n\n\n\nNow in the actual jump code we increase our jumpPhase by one, and calculate our jump velocity based on our set height using some maths. Then we add that to our velocity variable.\n\nAnd we’re done! Add the Ground and Jump scripts to your player and you should be able to jump. Tweak the three parameters to make your jump feel satisfying."},"Unity/Introduction/2D/Sprites-and-Spritesheet-Resources/index":{"slug":"Unity/Introduction/2D/Sprites-and-Spritesheet-Resources/index","filePath":"Unity/Introduction/2D/Sprites and Spritesheet Resources/index.md","title":"Unity - Sprites and Spritesheet Resources","links":[],"tags":["2d","animation","rigging","sprite","sprites","spritesheet","unity"],"content":"Notice\nThis is a temporary page to collate a handful of resources to get started with 2D sprites and 2D animation in Unity. This page will soon be replaced with a custom guide with clear step-by-step instructions for these features.\nPlease use the below resources, in conjunction with independent research, to get started.\nKeywords to google: “Unity Spritesheet Editor”, “Unity 2D animation package”, “Unity 2D Rigging”, “Unity spritesheet animations”\nUnity Learn: Introduction to Sprite Editor and Sheets\nIntroduction to the sprite editor - Learn how to import the sprite editor and slice an image into multiple sprites\nlearn.unity.com/tutorial/introduction-to-sprite-editor-and-sheets#\n\nUse several sprites to create a 2D character rig\nIntroduction to 2D character rigging - If you have a sprite sheet where each sprite is a different part of the character, this tutorial teaches you how to combine and rig them to create an animatable character\nyoutu.be/k4LkNtp9\\_wU\nUnity Learn: Turn individual sprites into an animation\nIntroduction to sprite animations - If you have a spritesheet where individual sprite acts as a frame of animation, this tutorial teaches you how to combine them together to create a “stop-motion”-like animation\nlearn.unity.com/tutorial/introduction-to-sprite-animations#\n"},"Unity/Introduction/2D/index":{"slug":"Unity/Introduction/2D/index","filePath":"Unity/Introduction/2D/index.md","title":"Unity - 2D","links":[],"tags":[],"content":""},"Unity/Introduction/First-3D-Game/index":{"slug":"Unity/Introduction/First-3D-Game/index","filePath":"Unity/Introduction/First 3D Game/index.md","title":"Unity 3D - Introduction [shp-icon icon=\"new\"]","links":["images/image.pngex=67d33e21-and-is=67d1eca1-and-hm=cafe186a80be3721e96cfcada229f6f9af32541912635195ffd655bba388b173-and-"],"tags":["2d","introduction","scripting","unity"],"content":"[icon name=&quot;computer&quot;] Lab Note\nTest Commit\nThis guide can be followed while using the GDA Computer Suite. Sections which are unique to the computer suite are marked with [icon name=&quot;computer&quot;]\n\nWhy Unity?\n\n\nLarge and active community of professionals and hobbyists\n\n\nUsed widely in many creative industry\n\n\nCross-platform development\n\n\nRich 2D and 3D capabilities\n\n\nReal-time experiences for AR, VR, mobile, desktop and web (Not limited to just games!)\n\n\nContinuous updates with LTS (Long Term Support) versions\n\n\nFree for students and personal use!\n\n\nLaunching Unity\n[icon name=&quot;computer&quot;] The lab PCs are pre-installed with Unity 2022.3.34f\n\n\nIf you’re using a later version (Unity 6 or above), your interface may differ from this guide but the content will still be relevant.\n\n\nType “Unity” into the Windows search box\n\n\n[icon name=&quot;computer&quot;] Important if using the Computer Lab: Click on “Unity 2022.3.34f1” not “Unity Hub”. This will still open the Unity Hub launcher, but will preload the editor into the launcher for you.\n\n\nOnce open, Unity Hub will ask you to sign in. If you don’t have an account, create one with your student email.\n\n\nCreating your first project\n\n\nCreate a new Unity project through Unity Hub\n\n\n\n\nChoose the Universal 3D template\n\n\nSet your project name\n\n\n[icon name=&quot;computer&quot;] Computer Suite: Save the project to the D drive\n\n\nLeave “Connect to Unity Cloud” checked\n\n\nLeave “Use Unity Version Control” unchecked - this is separate to Git Version Control and may cause confusion between the two\n\n\nBuilt-in Renderer/ URP/ HDRP\n\nBuilt-In Renderer\n- General Purpose + Legacy\n- This project type is being phased out\n\nUniversal Render Pipeline (URP)\n- Modern go-to option\n- Artist-friendly features\n- Best for cross-platform\n- Best for most cases and is the recommended option for most projects\n\nHigh Definition Render Pipeline (HDRP)\n- Advanced graphical features intended for high-end hardware\n- Difficult to fully utilise\n- Ask if you need this for your project\nSetting Up Version Control\nIn order to save and track changes to your project so that it can be accessed by you and your teammates from any machine, it is highly recommended to set up Git version control for your project.\nIn Unity\n\nHierarchy: Displays all the game objects in the current scene. Here you can manage the organization of objects. By default your project will have a Camera, a Light, and a “Global Volume” used for post processing effects.\nScene: A visual representation of the game world. This is where you can move, manipulate, and arrange objects in a 3D or 2D space.\nInspector: Shows detailed properties and settings for the currently selected game object, component, or asset. You can modify values like position, rotation, and script variables here.\nProject/Console: Use the tab to change between these two windows.\nThe Project window contains all the assets, scripts, and resources for your project. It’s organized into folders and allows you to manage the project’s files.\nThe Console window will show you any errors/warnings in your project as well as any custom messages you wish to output here.\nScenes\nScene: A space that holds all of the Game Objects needed for your game. A small game could only need one scene for the whole thing, while a bigger game might need one scene for every level or environment.\n\n\nFor example, in a more complex project you can use scenes to organize your game by content:\n- [Main Menu Scene]\n- [Level 1 Scene]\n- [Level 2 Scene]\n- The scenes don’t have to be sequential, for instance you could have [Hub World], [Building 1], [Building 2], [Settings Menu] as separate scenes.\n\n\nScenes are essential for organization, performance, and robustness!\n\n\nFor most purposes, you will only have one scene loaded in your game at a time.\n\n\nWhen you ‘save’ your Unity project, you are saving the currently loaded scene.\n\n\nWhen you first load a project, Unity will create a new scene titled “SampleScene.” You can find it within the Project panel under Assets/Scenes:\n\nIt is a good idea to rename this scene. You can name it anything as long as it roughly describes the intended contents of the scene. We will be implementing a basic First Person Controller here, so name it “FirstPersonTesting” for now.\nGameObjects and Components\n\n\nGameObjects: Fundamental objects within Unity\nA scene can have an unlimited number of GameObjects, representing anything and everything in your scene from your player; to props or weapons; to a terrain or building. Anything in your scene will be a GameObject.\nA GameObject can have a mesh attached to it or be invisible.\n\n\nGameObjects don’t have any inherent functionality by themselves, but can be extended through the use of Components and Scripts.\n\n\nA GameObject doesn’t have to be something physical within your scene. For example we can use invisible GameObjects to hold scripts that run in the background.\n\n\n\n\nUnity has hundreds of built-in Components, but in many cases we will need to write our own Components in the form of C# Scripts.\n\n\nCreating your first GameObject\n\n\nLets create a new GameObject which will represent our player.\n\n\nCreate a new capsule object by right-clicking within the Hierarchy window and select\n3D Object → Capsule\n\n\n\nInspector Window\n\n\nSelect the Capsule by clicking on it in the \u000bHierarchy. You will see that it becomes highlighted\n\n\nThe top of the inspector window allows you to activate/deactivate your object, rename it, as we all more advanced options which we will skip for now.\n\n\nThis is followed by the object’s components. On our capsule, by default these are:\n\n\nTransform:\u000b All GameObjects include a Transform component. This defines the position, rotation, and scale of the\u000b object\n\n\nMesh Filter: Defines the mesh (3D model) for the object.\n\n\nMesh Renderer: Renderers the mesh defined by the Mesh Filter\n\n\nCapsule Collider: Provides a collision mesh for the capsule. The collider is used to give objects physical interactivity within Unity’s Physics system\n\n\nMaterial: The material for the object. The default material can not be edited but a new material can be created and dragged here to replace it.\n\n\n\n\nFinally at the bottom you will find the “Add Component” button. Use it to browse the catalogue of Unity’s built-in components. Any user-made scripts will also be available here. Note that not all components are compatible with each other and some components can only be added once per object.\n\n\nUse the inspector to set the position of the Capsule to X: 0, Y: 5, Z: 0\n\n\nProperties\n\n\nWe can interact with components and \u000bscripts through properties.\n\n\nEach component/script has its own set of properties which can be edited\n\n\n\n\n\nIf you are ever unsure what a property \u000bdoes, just hover over it!\n\n\nTip: Googling “Unity Capsule Collider” or any other Component name will often give you the \u000bdocumentation page for the component as one of \u000bthe first results.\u000b\u000b Don’t worry about the details for now though!\nRecap of Structure\n\n\n\nA Unity Project can have any number of Scenes\n\n\nA scene can have any number of GameObjects\n\n\nA GameObject will always have Transform and Material components, as well any number of other built-in components or Scripts\n\n\nComponents and scripts will have properties which you can manipulate\n\n\nPlay Mode\n\nPlay Mode is a core feature in Unity that lets you test your game directly in the editor. Think of it as a “preview” of your game that you can run at any time. You can find the play mode controls at the top of the Unity editor.\nWhen you enter Play Mode:\n\n\nUnity compiles your scripts, turning them into internal code for Unity to run.\n\n\nThe editor interface changes (often with a colored tint to remind you you’re in Play Mode)\n\n\nThe “Game” tab opens and your game starts running from the active scene\n\n\nAny changes in Play Mode will be reverted once you exit it\n\n\nTo exit Play Mode, just click the Play button again, and Unity will return to its normal editing state.\nPlay Mode is essential for game development because it offers rapid iteration - you can make changes, test them immediately, and refine your game without the time-consuming process of building (turning it into an application) every time.\nPhysics\nUnity has a powerful physics engine, handling simulation of physical interactions in your game world. This includes but is not limited to:\n\n\nRigid body dynamics: Controls how solid objects move, rotate, and interact when forces are applied\n\n\nObject movement and collisions: Detects when objects bump into each other and calculates appropriate responses\n\n\nGravity and forces: Applies gravitational pull and lets you add custom forces like wind, explosions, or magnetism\n\n\nMaterial properties: Manages how objects bounce, slide, and interact through friction, bounciness, and density\n\n\nJoints and constraints: Connects objects together with hinges, springs, or fixed connections\n\n\nRagdoll effects: Simulates lifelike character movements when they fall or get hit\n\n\nRaycasting: Shoots invisible lines to detect objects in specific directions (useful for line-of-sight checks or targeting)\n\n\nTriggers: Special collision areas that detect when objects enter but don’t physically block them\n\n\n\n\n\nRigidbody Dynamics\nIn real-world physics, a rigid body is any physical body that does not deform or change shape under physical forces.\nTo simulate physics-based behavior such as movement, gravity, collision, and joints, you need to configure objects in your scene as rigid bodies. For them to interact with other objects they also need a collider.\nLet’s test this by creating a new Cube. Right click in the hierarchy and select 3D Object → Cube.\nSet its position to X: 0, Y: 5, Z:2.\nAdd a Rigidbody component to the Cube by selecting it and scrolling down in the inspector. Click “Add Component”. This will open up the component catalogue where you can either type in “Rigidbody” or find it under the Physics section.\n\nAdding a second physics object (Floor)\nLets a floor to our scene! Right click in the Hierarchy Panel and select 3D Object → Plane.\nSet the position to X: 0, Y: 0, Z: 0\nYour scene should look like this. Enter Play Mode and you will see the Cube is affected by gravity! However the capsule is not, as it does not have a rigidbody. Do not add one to the capsule yet, as for the process for characters is slightly different!\nimage.pngex=67d33e21-and-is=67d1eca1-and-hm=cafe186a80be3721e96cfcada229f6f9af32541912635195ffd655bba388b173-and-\nYou should now be familiar with the basic structure of Unity and have a rough idea of how to create an object affected by physics.\nExercises\n[formidable id=3]"},"Unity/Introduction/First-Person-Controller/index":{"slug":"Unity/Introduction/First-Person-Controller/index","filePath":"Unity/Introduction/First Person Controller/index.md","title":"Unity 3D - First Person Controller [shp-icon icon=\"new\"]","links":["images/image.pngex=67d33aff-and-is=67d1e97f-and-hm=d4b4fe923745fb055f7b89df8749ad612e9bd7e413fc78227e1e52cd77e274e3-and-","images/image.pngex=67d344ec-and-is=67d1f36c-and-hm=d4dd892850a08f02cecde5a34bb6dfdcad1e7e9393d0796f8e35691c121a0f6d-and-"],"tags":["2d","introduction","scripting","unity"],"content":"[icon name=&quot;computer&quot;] Lab Note\nThis guide can be followed while using the GDA Computer Suite. Sections which are unique to the computer suite are marked with [icon name=&quot;computer&quot;]\n\nCreating a simple First Person Controller\nLearning any application is best done through practice! To really solidify the above concepts, lets create a very basic First Person Controller. This will also introduce you to basic scripting!\nDecomposing the task\n\nGoing from nothing to a fully controllable character seems like a daunting task, so let’s break it down!\nJust kidding, but seriously when it comes to implementing any feature its a good idea to decompose it into smaller tasks. So what is involved in making a first-person controller?\nParenting Objects (Create First-Person Camera)\nIn your scene you will a GameObject named “Main Camera” by default. This object contains a Camera component and the output of the camera is displayed when you enter Play Mode.\nCurrently the camera probably exists outside of the player, and for a first-person controller we want the camera to be from the perspective of the player’s eyes. To do this we need to make the camera gameobject a “Child” of the player.\nBy making an object a child of another object it becomes “attached” and any transformations on the parent are subsequently applied to the child.\nTo make the “Main Camera” object a child of the “Capsule” object, simply drag it over in the hierarchy.\nIf your Hierarchy looks like this then you have done it correctly:\nimage.pngex=67d33aff-and-is=67d1e97f-and-hm=d4b4fe923745fb055f7b89df8749ad612e9bd7e413fc78227e1e52cd77e274e3-and-\nSet the position of the camera object to X: 0, Y: 0.5, Z: 0. Notice how now that the camera is a child of the capsule, its position is relative to the capsule. By setting the position to those values, the camera is 0.5 units above the center of the capsule, or roughly at eye-level.\nEnter Play Mode - you are now seeing the “First Person View” of the capsule! Not much is visible yet. As the camera is inside the capsule, the capsule itself is not visible but this okay and is what we want.\nMoving the Capsule Player\nWhats next? Well we probably want to be able to move the capsule (ie our player) using the keyboard\nCharacter Controller Component\nThe reason we didn’t add a rigidbody to our player was because Unity offers a special component - the Character Controller - which acts as a rigidbody and collider in one, with special behavior designed specifically for controlling a character in a 3D environment.\nWhy use a Character Controller and not a Rigidbody for a player?\nMost games don’t treat players as realistic objects, and actually the way that we expect our character to move isn’t exactly super realistic. Unity describes this best:\n\nThe traditional Doom-style first person controls are not physically realistic. The character runs 90 miles per hour, comes to a halt immediately and turns on a dime. Because it is so unrealistic, use of Rigidbodies and physics to create this behavior is impractical and will feel wrong. The solution is the specialized Character Controller. It is simply a capsule shaped Collider which can be told to move in some direction from a script. The Controller will then carry out the movement but be constrained by collisions. It will slide along walls, walk up stairs (if they are lower than the Step Offset) and walk on slopes within the Slope Limit.\n\nimage.pngex=67d344ec-and-is=67d1f36c-and-hm=d4dd892850a08f02cecde5a34bb6dfdcad1e7e9393d0796f8e35691c121a0f6d-and-\nThat’s not to say using a Rigidbody, or any method is incorrect. It all depends on how you want your movement to function and feel. For a physics-based platformer for example, you would want to use a rigidbody and let Unity handle all the work. For a parkour game, you may use a Character Controller but define and handle all of the physics manually through a script (giving you explicit control of how player velocity is calculate, for example).\nEach approach has its own pros and cons, but we will be using CharacterController for this guide as it is robust and gives you more control over the movement of the player.\nRemove the Capsule Collider on your player and add a Character Controller component. The inspector for your player should look like this:\nUsing the Character Controller (Your first Script)\nTo use the character controller component, we will need to create our own script. This guide assumes basic programming knowledge. Don’t worry if you don’t have this, as all code is provided and explained.\nSet Up Your Scripting Environment\n\n\nWithin your Assets folder, create a new folder \u000bfor Scripts\n\n\nSelect your default Script Editor\n\n\nAt the top of the screen, go to Edit → Preferences\n\n\nSelect the External Tools tab\n\n\nSet your External Script Editor to ‘Rider’\n\n\nDon’t change any other settings at this moment\n\n\n\n\n\nCreate a script\n\n\nTime to create your own script!\n\n\nWithin your Scripts folder, create a new script by right-clicking and selecting Create → C# Script\n\n\nName your Script “BasicMovement” (no spaces):\n\n\n\n\n\nConvention recommends pascal case for script names\n\nE.g. PlayerController, CameraEffectsSystem, LevelOneProperties\n\n\n\nAdd your script to your capsule (same way you would add a component)\n\n\nThen double-click the script to open it within Rider (a C# script editor)\n\n\nIn Rider\nYou should now see this. What you are looking at is default code which unity generates any time you create a new script:\n\nNotice the two functions Start() and Update(), don’t worry about anything else for now. All you need to know is that you can write code within those functions (between the curly brackets below each respective function).\nCode that you write within Start() will only run once, when you enter Play Mode.\nCode that you write within Update() will run every frame (hundreds of times per second)\n\nInteracting with the Character Controller Component\nIn order for our script to interact with the Character Controller component, we need to create a reference to it within our script:\nC#\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class BasicMovement : MonoBehaviour\n{\n    // Start is called before the first frame update\n    void Start()\n    {\n        \n    }\n\n    // Update is called once per frame\n    void Update()\n    {\n        var characterController = GetComponent&lt;CharacterController&gt;();\n    }\n}\n\nWe can get a reference to any component on the same object as the script using using GetComponent&lt;&gt;(). On line 16 we use this to save the reference in a variable called characterController.\nAdding Movement\nBy default, the Character Controller does not handle gravity. If we want our player to be affected by a gravity, we have to ‘activate it’ by triggering a move.\nC#\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class BasicMovement : MonoBehaviour\n{\n    // Start is called before the first frame update\n    void Start()\n    {\n        \n    }\n\n    // Update is called once per frame\n    void Update()\n    {\n        var characterController = GetComponent&lt;CharacterController&gt;();\n        var velocity = transform.forward;\n        characterController.SimpleMove(transform.forward);\n    }\n}\n\nThe above code makes the character move forward. Each time we use SimpleMove() the component also applies gravity.\nLets add a check for input so we only move the player forward when the W key is pressed:\nC#\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class BasicMovement : MonoBehaviour\n{\n    // Start is called before the first frame update\n    void Start()\n    {\n        \n    }\n\n    // Update is called once per frame\n    void Update()\n    {\n        var characterController = GetComponent&lt;CharacterController&gt;();\n        var velocity = Vector3.zero;\n        \n        if(Input.GetKey(KeyCode.W))\n        {\n            velocity += transform.forward;\n        }\n        \n        characterController.SimpleMove(velocity);\n    }\n}\n\nEach frame, the velocity is reset to zero. If W is pressed, we are adding the forward direction to the velocity.\nRepeat for the other directions:\nC#\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class BasicMovement : MonoBehaviour\n{\n    // Start is called before the first frame update\n    void Start()\n    {\n        \n    }\n\n    // Update is called once per frame\n    void Update()\n    {\n        var characterController = GetComponent&lt;CharacterController&gt;();\n        var velocity = Vector3.zero;\n        \n        if(Input.GetKey(KeyCode.W))\n        {\n            velocity += transform.forward;\n        }\n        if (Input.GetKey(KeyCode.S))\n        {\n            velocity -= transform.forward;\n            //to add &quot;backwards&quot; we subtract &quot;forwards&quot;\n        }\n        if (Input.GetKey(KeyCode.D))\n        {\n            velocity += transform.right;\n        }\n        if (Input.GetKey(KeyCode.A))\n        {\n            velocity -= transform.right;\n            //to add &quot;left&quot; with subtract &quot;right&quot;\n        }\n        \n        characterController.SimpleMove(velocity.normalized);\n    }\n}\n\nYou might notice that when moving diagonally the player moves faster. To fix this we replace velocity with velocity.normalized on line 39. Learn why this works\nLets add a new speed property to our script:\nC#\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class BasicMovement : MonoBehaviour\n{\n\n\t\tpublic float speed;\n\t\t\n    // Start is called before the first frame update\n    void Start()\n    {\n        \n    }\n\n    // Update is called once per frame\n    void Update()\n    {\n        var characterController = GetComponent&lt;CharacterController&gt;();\n        var velocity = Vector3.zero;\n        \n        if(Input.GetKey(KeyCode.W))\n        {\n            velocity += transform.forward;\n        }\n        if (Input.GetKey(KeyCode.S))\n        {\n            velocity -= transform.forward;\n            //to add &quot;backwards&quot; we subtract &quot;forwards&quot;\n        }\n        if (Input.GetKey(KeyCode.D))\n        {\n            velocity += transform.right;\n        }\n        if (Input.GetKey(KeyCode.A))\n        {\n            velocity -= transform.right;\n            //to add &quot;left&quot; with subtract &quot;right&quot;\n        }\n        \n        characterController.SimpleMove(velocity.normalized*speed);\n    }\n}\n\nWe can create a new property for our script by creating a public variable outside of a function (usually at the top of the script)\n\nYou are now able to change the speed within the editor and even in play mode. Set this to a value other than 0 (what happens if you set it to a negative number?)\nOne last thing for movement - if you have any rigidbody objects in your scene, you will notice that they do not get pushed by the capsule. For this to happen, we have to add velocity to the object whenever the CharacterController detects a collision:\nC#\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class BasicMovement : MonoBehaviour\n{\n    public float speed;\n    // Start is called before the first frame update\n    void Start()\n    {\n        \n    }\n\n    // Update is called once per frame\n    void Update()\n    {\n        var characterController = GetComponent&lt;CharacterController&gt;();\n        var velocity = Vector3.zero;\n\n        if(Input.GetKey(KeyCode.W))\n        {\n            velocity += transform.forward;\n        }\n        if (Input.GetKey(KeyCode.S))\n        {\n            velocity -= transform.forward;\n        }\n        if (Input.GetKey(KeyCode.D))\n        {\n            velocity += transform.right;\n        }\n        if (Input.GetKey(KeyCode.A))\n        {\n            velocity -= transform.right;\n        }\n        \n        characterController.SimpleMove(velocity.normalized*speed);\n    }\n\n    void OnControllerColliderHit(ControllerColliderHit hit)\n    {\n        Rigidbody otherObject = hit.collider.attachedRigidbody;\n        \n        // if object has no rigidbody or shouldnt be movable, return (cancel this function)\n        if (otherObject == null || otherObject.isKinematic) {\n            return;\n        } \n        \n        otherObject.velocity = hit.moveDirection;\n    }\n}\n\nOnControllerColliderHit is triggered by the CharacterController component whenever it detects that a collision has happened.\nMouse Controls\nThe third and last component of a first person controller is the ability to move the camera (and rotate the player) using the mouse.\nCreate a new script called ‘MouseLook’\nFor this part, the code is provided for you. Simply copy and paste it into your script. Whats the catch? This part will involve you completing a series of exercises in order to make the script work and to add further functionality. Primarily to test your knowledge, but also to get you more comfortable with editing code.\nC#\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class MouseLook : MonoBehaviour\n{\n    public GameObject cameraObject;\n    private Vector2 rotation;\n\n    void Start()\n    {\n        Cursor.lockState = CursorLockMode.Locked;\n    }\n\n    void Update()\n    {\n        rotation.y += Input.GetAxis(&quot;Mouse X&quot;) * 1.0f;\n        rotation.x += -Input.GetAxis(&quot;Mouse Y&quot;) * 1.0f;\n        rotation.x = Mathf.Clamp(rotation.x, -80, 80);\n        \n        //Rotate capsule left and right\n        transform.eulerAngles = new Vector2(0,rotation.y);\n        \n        //Rotate camera object up and down\n        cameraObject.transform.localRotation = Quaternion.Euler(rotation.x, 0, 0);\n    }\n}\n\nAdd the script to your capsule player object. You should see that the script has a property, but maybe not one you have seen before. Instead of a number, this property wants a GameObject:\n\nThe script will not work (in fact it will create an error) unless this property is set.\nEnd-Of-Guide Exercises\n[formidable id=2]"},"Unity/Introduction/Glossary/index":{"slug":"Unity/Introduction/Glossary/index","filePath":"Unity/Introduction/Glossary/index.md","title":"Unity - Glossary","links":[],"tags":["scripting","unity"],"content":"Note: This is a student-submitted guide. Please comment or get in touch with me (Parker) for suggestions or clarification!\nEditor Terms\n\n\n\nScene - A space that holds all of the Game Objects needed for your game. A small game could only need one scene for the whole thing, while a bigger game might need one scene for every level or environment. When you edit in Unity you will be editing a Scene asset.\n\n\nComponents - The “building blocks” of any Game Object that change properties or functionality.\n\nComponents can be things like meshes, materials, Rigidbody components that give them mass and physics, colliders, etc.\n\n\n\nGame Objects - The fundamental objects within Unity.\n\nGame Objects represent props, characters, scenery. Can have a model or be empty.\n\n\n\nScripts - Components comprised of a collection of C# code that let you add functionality to any object, or change its behavior.\n\nA script can be given to any object to give it that functionality. For example, a player character could have a Movement script, or an NPC could have an AI script.\n\n\n\nC# &amp; Scripting\n\n\nClass - A block of code that contains Variables and Functions.\n\nOne class can inherit from another, which means it gets all its variables and functions by default. For example, all scripts you create inherit the ‘MonoBehavior’ class, which contains all the variables and functions needed to make a Unity game script.\n\n\n\nVariable - A piece of data given a name as a signifier. In C# it is declared, or created, by stating its Data Type and Scope.\n\n\n\nYou do not need to assign a value right away when declaring a variable, but the data type is necessary. If you do not assign the scope it is assumed to be private, but you should do it anyway so it’s clear in your code.\n\n\nVariables don’t have to just be data, they can also refer to certain Game Objects in Unity.\n\n\n\n\nData Type - Specifies what type of data a variable is, which decides how it is processed by the engine and what processes are allowed to be performed on it. C# does not have a single data type for “numbers” in general for instance, it gets a bit more specific than that. Common data types in Unity include:\n\n\nString - A string of Unicode characters, like a word or a sentence.\n\nExample: “hello”, “world”, “hello world”\n\n\n\nInteger (or Int) - A whole number.\n\nExample: 1, 28, 200\n\n\n\nFloat - A decimal number. It can store whole numbers too. You usually want to use floats for numbers.\n\nExample: 3.78, 5.89, 356\n\n\n\nDouble - Like a float, but has room for bigger numbers, or more decimal places for higher precision. Only use it when you need it, float will work in most cases.\n\nExample: 5.9999999999999\n\n\n\nBoolean (or Bool) - A value that can only be “true” or “false”.\n\nExample: true, false\n\n\n\nVector2 - A vector made up of two float numbers. Usually describes position or rotation in 2D space, but it has a lot of different use cases.\n\nExample: (1.3, 2.6)\n\n\n\nVector3 - Like Vector2 but with 3 numbers. Usually used for position or rotation in 3D space.\n\nExample: (1.3, 2.6, 5.2)\n\n\n\n\n\nData Scope - The area of code within which a variable can be used in.\n\n\nPrivate - Can only be used within the class it is declared in.\n\n\nPublic - Can be used by any script. Try to avoid making everything public if you don’t need to, as if any variable can be accessed and edited from anywhere else in your game it can lead to bugs that are very tricky to diagnose. Keeping all scripts as self-contained as possible helps you out in the long run.\n\n\n\n\nFunctions - A collection of code that is given a name as a signifier. When this name is called in your script, or by other scripts, the code will be run. Also known as “methods”.\n\n\nFor example, here is a function that returns whatever the input number plus one whenever it is called.\n\n\n\n\n\nFunctions can optionally take in data as an input. This is stored as a variable inside the function and the name and type of the input is declared when making the function.\n\n\nFunctions can also return the value of a variable if need be. The type of the variable is set when the function is declared.\n\n\nFunctions also have a scope from which they can be called, just like variables.\n\n\n\n"},"Unity/Introduction/Input-System-Quick-Start/index":{"slug":"Unity/Introduction/Input-System-Quick-Start/index","filePath":"Unity/Introduction/Input System Quick-Start/index.md","title":"Unity - Input System Quick Start","links":[],"tags":[],"content":"Avaliable on Loop\nThis guide has not been ported to tech.wsagames.com yet, but it is available on Microsoft Loop:\nInput System Quick Start.loop"},"Unity/Introduction/Simple-Orbit-Camera/index":{"slug":"Unity/Introduction/Simple-Orbit-Camera/index","filePath":"Unity/Introduction/Simple Orbit Camera/index.md","title":"Unity - Simple 3D Orbit Camera","links":[],"tags":["3d","scripting","unity"],"content":"Note: This is a student-submitted guide. Please comment or get in touch with me (Parker) for suggestions or clarification!\nIntro\nIn this tutorial, you will learn how to make a simple third-person 3D camera view that “orbits” around the player with the mouse. For this we will also be using Unity’s new input system. I suggest having a read through the other tutorials prior to this as a beginner’s knowledge of scripting is recommended.\nPart One - Setting Up Inputs\nEnsure the Unity Input system is installed as explained in the other tutorials, and right-click &gt; Create an Input Actions asset in your Assets panel. Create a new Action Map (if you have not got one already) called Gameplay, and rename the Action that was just created to Look. In the Properties panel on the right change the Action Type to Value and the Control Type to Any.\n\n\n\nIf your game already has an Action Map, just create a new Action in that.\n\n\nPress the arrow next to Look to show the Bindings for the action. Select the binding that should already be there and set its path to Delta [Mouse].\n\nClick Save Asset at the top of the Input Actions editor window and close it. In the Inspector click Generate C# Class then click Apply.\n\nPart Two - Setting the Scene\nNow we will create the camera and the player character. In the Hierarchy panel right click and create a 3D Object that will be your player (if you haven’t created a 3D character already). Then create a Camera object. This should be all we need for now.\n\n\n\nI used a Cube for my character for the sake of simplicity.\n\n\nPart Three - Creating the Script\nCreate a new folder in your Assets folder called Scripts. Inside that, create a new C# Script and call it OrbitCamera.\nInside the script, we first start by declaring some private variables with the [SerializeField] prefix, so we can change them in the Editor whenever we want. These will be the target our camera looks at, the sensitivity of the camera (aka how fast it will orbit around responding to mouse movement), the radius at which the camera orbits, and how much camera smoothing is applied.\n\nNow we declare two variables that will contain the yaw and pitch of the camera. This essentially means the angle the camera is pointing side-to-side and up-and-down respectively.\n\n\n\nAs you can see in this incredibly detailed diagram, yaw is a rotation on the Y axis and pitch is a rotation on the X axis (at least in Unity).\n\n\nAlso, include a variable called inputActions for our Input Actions asset.\n\nIn our Start method, we first set our yaw and pitch by getting the current rotation of the camera in the Y and X axis.\n\nThen we set the inputActions variable to be our Input Actions asset.\n\nNow we will create a method called Look, that is going to take the value from the Delta [Mouse] binding we made earlier (essentially how much the mouse has moved in the last frame) and move the camera accordingly.\nFirst we make two local variables inside the method that are going to split the input into the X and Y parts of our mouse movement seperately.\n\nThen, we change the yaw and pitch with them respectively, also including our sensitivity variable. Note here that I take mouseY away from the pitch, to make sure our camera pitches down when we move our mouse down.\n\nFinally, we add the following line of code. This essentially smoothly moves (or linearly interpolates, if you wanna get technical) the camera’s current rotation to a new one, with our new pitch and yaw values. The rate at which this shift in rotation happens is based on our smoothing variable.\n\nNow we have to add to our Update method to use the Look method we made. As the input for Look, read the value of our Look binding in the inputActions asset.\nAfter that, we put in a line of code that uses the transform.forward variable to get the forward direction of whereever we’re looking at, and uses that to move the camera back from our target according to orbitRadius. We can now increase orbitRadius to “zoom out” away from our target. This must happen after you rotate the camera with the Look method!\n\nSave the script and add it to your Camera object. Drag the 3D character object we made earlier into the “Target” value under the script in the Inspector window, and adjust the values as you see fit. Here are mine for reference.\n\nNow, run the game and see what happens!\n\nYou can now move the mouse to orbit around your object. However, if you keep moving it up you’ll see you can keep flipping around it, which isnt how a third-person camera usually works. We need some code to stop the pitch from getting too high or too low.\nPart Four - Limiting the Pitch\nBack in our OrbitCamera script, go back to the Look method. Right after we change our pitch variable and before doing the rotation, we insert a line of code that uses the Clamp method to ensure the pitch doesn’t go below or above a specified number. In this example we will limit it to 80 degrees maximum to stop the spinning, and 0 degrees minimum so it doesn’t go through the floor.\n\nSave the script, press play and you’re done!\nNow you should have a proper 3D orbit camera! More complex solutions with things like colliding with walls are also possible with packages like Cinemachine, but this works as a very simple solution for prototyping.\nFinal Code\nHere is the finished code. WARNING: Please try to follow the tutorial first and not just copy-paste this! If you have not at least attempted to understand the code I will not provide any help or troubleshooting.\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class OrbitCamera : MonoBehaviour\n{\n    [SerializeField] private Transform target;\n    [SerializeField] private float sensitivity = 1f;\n    [SerializeField] private float orbitRadius = 5f;\n    [SerializeField] private float smoothing = 5f;\n\n    private float yaw;\n    private float pitch;\n\n    private InputActions inputActions;\n    \n    // Start is called before the first frame update\n    void Start()\n    {\n        yaw = transform.eulerAngles.y;\n        pitch = transform.eulerAngles.x;\n\n        inputActions = new InputActions();\n        inputActions.Gameplay.Enable();\n    }\n\n    void Look(Vector2 mouseDelta)\n    {\n        float mouseX = mouseDelta.x;\n        float mouseY = mouseDelta.y;\n\n        yaw += mouseX * sensitivity;\n        pitch -= mouseY * sensitivity;\n\n        pitch = Mathf.Clamp(pitch, 0f, 80f);\n        \n        transform.rotation = Quaternion.Lerp(transform.rotation, Quaternion.Euler(pitch, yaw, 0), 1/smoothing);\n    }\n\n    // Update is called once per frame\n    void Update()\n    {\n        Look(inputActions.Gameplay.Look.ReadValue&lt;Vector2&gt;());\n        transform.position = target.position - transform.forward * orbitRadius;\n    }\n}\n"},"Unity/Introduction/index":{"slug":"Unity/Introduction/index","filePath":"Unity/Introduction/index.md","title":"Unity - Introduction","links":[],"tags":[],"content":""},"Unity/Shaders/Full-Screen-Shaders/index":{"slug":"Unity/Shaders/Full-Screen-Shaders/index","filePath":"Unity/Shaders/Full-Screen Shaders/index.md","title":"Unity - Full Screen Shaders","links":[],"tags":[],"content":"Avaliable on Loop\nThis guide has not been ported to tech.wsagames.com yet, but it is available on Microsoft Loop:\nFull-Screen Filter Shaders.loop"},"Unity/Shaders/index":{"slug":"Unity/Shaders/index","filePath":"Unity/Shaders/index.md","title":"Unity - Shaders","links":[],"tags":[],"content":""},"Unity/index":{"slug":"Unity/index","filePath":"Unity/index.md","title":"Unity Homepage","links":[],"tags":[],"content":"flowchart TD\n    A[Christmas] --&gt;|Get money| B(Go shopping)\n    B --&gt; C{Let me think}\n    C --&gt;|One| D[Laptop]\n    C --&gt;|Two| E[iPhone]\n    C --&gt;|Three| F[fa:fa-car Car]\n    click B &quot;www.github.com&quot; &quot;This is a link&quot;\n"},"index":{"slug":"index","filePath":"index.md","title":"Welcome to the Guides Repository!","links":[],"tags":[],"content":"flowchart TD\n    A[Christmas] --&gt;|Get money| B(Go shopping)\n    B --&gt; C{Let me think}\n    C --&gt;|One| D[Laptop]\n    C --&gt;|Two| E[iPhone]\n    C --&gt;|Three| F[fa:fa-car Car]\n    click B &quot;www.github.com&quot; &quot;This is a link&quot;\n"}}